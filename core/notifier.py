# core/notifier.py
import os
import asyncio
import telegram
import logging
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Dict, Any, Union
import json
import re


logger = logging.getLogger(__name__)

# Define the timezone
IST = ZoneInfo("Asia/Kolkata")


SENTIMENT_EMOJIS = {
    "Strongly Bullish": "ðŸ‚",
    "Moderately Bullish": "ðŸ“ˆ",
    "Neutral": "ðŸ“Š",
    "Cautious/Bearish": "ðŸ“‰",
    "Strongly Bearish": "ðŸ»",
}

# The character limit for Telegram messages. Set slightly below the hard max for safety.
MAX_TELEGRAM_LENGTH = 4000


class TelegramNotifier:
    def __init__(self):
        self.bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        self.chat_id_summaries = os.getenv("TELEGRAM_CHAT_ID_SUMMARIES")
        self.chat_id_links = os.getenv("TELEGRAM_CHAT_ID_LINKS")
        self.is_enabled = bool(
            self.bot_token and self.chat_id_summaries and self.chat_id_links
        )
        if self.is_enabled:
            logger.info("âœ… Telegram Notifier initialized successfully.")
        else:
            logger.warning("âš ï¸ Telegram Notifier is DISABLED. Missing token or chat ID.")

    def _escape_markdown(self, text: str) -> str:
        """
        Escapes text for Telegram's MarkdownV2 parser.
        """
        if not isinstance(text, str):
            text = str(text)
        escape_chars = r"_*\[\]()~`>#+=|{}.!-"
        
        return re.sub(
            f"([{re.escape(escape_chars)}])", lambda m: f"\\{m.group(1)}", text
        )

    async def _send_message(self, chat_id: str, message: str) -> bool:
        """Sends a message as plain text with a  retry mechanism."""
        if not self.is_enabled:
            return True
        bot = telegram.Bot(token=self.bot_token)

        plain_text_message = (
            message.replace("_", "").replace("*", "").replace("`", "").replace("\\", "")
        )

        for attempt in range(1, 4):
            try:
                await bot.send_message(
                    chat_id=chat_id,
                    text=plain_text_message,
                    parse_mode=None,
                    disable_web_page_preview=True,
                    read_timeout=30,
                    write_timeout=30,
                    connect_timeout=30,
                )
                logger.info(
                    f"âœ… Message delivered to chat ID {chat_id} on attempt {attempt}."
                )
                return True
            except Exception as exc:
                logger.warning(f"Attempt {attempt} failed for {chat_id}: {exc}")
                if attempt < 3:
                    await asyncio.sleep(2**attempt)

        logger.error(f"âŒ Exhausted all retries for {chat_id}. Skipping message.")
        return False

    def _build_message_section(self, title: str, content: Any) -> str:
        """Helper to format a section of the message robustly."""
        if not content:
            return ""

        if isinstance(content, list):

            formatted_content = "\n".join(
                [f"â€¢ {self._escape_markdown(item)}" for item in content]
            )
        else:

            formatted_content = self._escape_markdown(str(content))

        return f"{title}\n{formatted_content}\n\n"

    async def notify_summary(self, summary_data: Dict[str, Any]) -> None:
        """Formats and sends a summary generated by the AI with plain, direct links."""
        company = self._escape_markdown(summary_data.get("company_name", "Unknown"))
        sentiment_text = summary_data.get("sentiment", "Neutral")
        sentiment_emoji = SENTIMENT_EMOJIS.get(sentiment_text, "ðŸ“Š")

        header = f"{sentiment_emoji} *AI Analysis: {company}*\n{self._escape_markdown('=========================')}\n\n"

        exec_summary_section = self._build_message_section(
            "ðŸŽ¯ *Executive Summary*", summary_data.get("executive_summary")
        )
        key_takeaway_section = self._build_message_section(
            "ðŸ’¡ *Key Takeaway*", summary_data.get("key_takeaway")
        )
        sentiment_line = f"*Sentiment:* `{self._escape_markdown(sentiment_text)}`"
        tone_line = f"*Management Tone:* `{self._escape_markdown(summary_data.get('management_tone', ''))}`"
        sentiment_tone_section = f"{sentiment_line}\n{tone_line}\n\n"
        financials_section = self._build_message_section(
            "ðŸ“ˆ *Key Financials*", summary_data.get("key_financials", [])
        )
        outlook_section = self._build_message_section(
            "ðŸš€ *Strategic Outlook*", summary_data.get("strategic_outlook", [])
        )
        risks_section = self._build_message_section(
            "âš ï¸ *Risks & Concerns*", summary_data.get("risks_and_concerns", [])
        )
        qa_section = self._build_message_section(
            "ðŸ—£ï¸ *Key Q&A Highlights*", summary_data.get("key_qa_highlights", [])
        )
        comparison_section = self._build_message_section(
            "ðŸ”„ *Previous Call Comparison*",
            summary_data.get("comparison_with_previous_call"),
        )

        message_parts = [
            header,
            exec_summary_section,
            key_takeaway_section,
            sentiment_tone_section,
            financials_section,
            outlook_section,
            risks_section,
            qa_section,
            comparison_section,
        ]
        message = "".join(part for part in message_parts if part)

        source_links = []
        if original_pdf_url := summary_data.get("original_pdf_url"):
            source_links.append(f"ðŸ”— *Current BSE PDF:*\n{original_pdf_url}")

        if current_media_links := summary_data.get("links", []):
            if media_url := current_media_links[0].get("url"):
                source_links.append(f"ðŸŽ¤ *Current Media Link:*\n{media_url}")

        if source_links:
            message += "*Source Links*\n" + "\n".join(source_links) + "\n\n"

        comparison_source_links = []
        if comparison_pdf_url := summary_data.get("comparison_pdf_url"):
            comparison_source_links.append(
                f"ðŸ“– *Comparison BSE PDF:*\n{comparison_pdf_url}"
            )

        if comparison_media_url := summary_data.get("comparison_media_url"):
            comparison_source_links.append(
                f"ðŸŽ§ *Comparison Media Link:*\n{comparison_media_url}"
            )

        if comparison_source_links:
            message += (
                "*Comparison Source Links*\n"
                + "\n".join(comparison_source_links)
                + "\n\n"
            )

        timestamp_str = self._escape_markdown(
            datetime.now(IST).strftime("_%Y-%m-%d %H:%M %Z_")
        )
        message += f"\n{timestamp_str}"

        if len(message) > MAX_TELEGRAM_LENGTH:
            safe_company_name = summary_data.get("company_name", "Unknown")
            logger.warning(
                f"AI-generated summary for {safe_company_name} still exceeded character limit. Truncating."
            )
            cutoff = MAX_TELEGRAM_LENGTH - 150
            message = message[:cutoff]
            message += self._escape_markdown(
                "\n\n... (message truncated due to length limits)"
            )

        await self._send_message(self.chat_id_summaries, message)

    async def notify_error(self, error_data: dict) -> None:
        """Sends a formatted error message with a plain link."""
        company = error_data.get("company_name", "Unknown")
        error_msg = error_data.get("message", "Unknown error")
        pdf_url = error_data.get("original_pdf_url", "")
        timestamp = self._escape_markdown(
            datetime.now(IST).strftime("%Y-%m-%d %H:%M %Z")
        )

        url_section = f"\n*Original PDF:*\n{pdf_url}" if pdf_url else ""

        message = (
            f"â€¼ï¸ *Processing Error*\n{self._escape_markdown('--------------------')}\n"
            f"*Company:* {self._escape_markdown(company)}\n"
            f"*Error:* `{self._escape_markdown(error_msg)}`"
            f"{url_section}\n\n_{timestamp}_"
        )
        await self._send_message(self.chat_id_links, message)

    async def notify_weblink_with_context(
        self, link_data: dict, previous_summary: dict
    ):
        """Notifies about a web link with historical context using plain links."""
        company = self._escape_markdown(link_data.get("company_name", "Unknown"))
        new_links = link_data.get("links", [])
        original_pdf_url = link_data.get("original_pdf_url", "")

        prev_summary_snippet = json.dumps(previous_summary, indent=2)
        escaped_snippet = self._escape_markdown(prev_summary_snippet)

        message_parts = [
            f"ðŸ”— *Web Link Found \\(With Historical Context\\)*\n{self._escape_markdown('--------------------')}",
            f"*Company:* {company}",
            "A new announcement is a web link, but a summary for a *previous* call exists\\.",
            f"*Original BSE PDF:*\n{original_pdf_url}",
            "*Discovered New Link\\(s\\):*\n"
            + "\n".join([f"â€¢ {link['url']}" for link in new_links]),
            f"*Previous Call Summary:*\n```json\n{escaped_snippet}\n```",
            f"_{self._escape_markdown(datetime.now(IST).strftime('%Y-%m-%d %H:%M %Z'))}_",
        ]

        message = "\n\n".join(message_parts)
        await self._send_message(self.chat_id_links, message)

    async def notify_weblink(self, link_data: dict) -> None:
        """Sends standard web link notifications with plain links."""
        company = self._escape_markdown(link_data.get("company_name", "Unknown"))
        links = link_data.get("links", [])
        original_pdf_url = link_data.get("original_pdf_url", "")
        if not links:
            return

        timestamp = self._escape_markdown(
            datetime.now(IST).strftime("%Y-%m-%d %H:%M %Z")
        )

        original_link_section = (
            f"*BSE PDF:*\n{original_pdf_url}\n" if original_pdf_url else ""
        )
        web_links = "\n".join([f"â€¢ {link['url']}" for link in links])

        message = (
            f"ðŸ”— *Web Link Found*\n{self._escape_markdown('--------------------')}\n"
            f"*Company:* {company}\n\n"
            f"{original_link_section}"
            f"*Discovered Links:*\n{web_links}\n\n"
            f"_{timestamp}_"
        )
        await self._send_message(self.chat_id_links, message)
